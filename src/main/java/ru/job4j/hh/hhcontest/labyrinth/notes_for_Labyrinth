LabyrinthRawVersion - для ручного тестирования

главная сложность задачи не в самом обходе в ширину матрицы (матрица = считай граф)
а в том, чтобы соблюсти все условия, когда мы упираемся в стену.
задача на мой взгляд распадается на несколько этапов:
1) Подготовить поле (тестовое, данные с хардкодом - сами тесты на джаве я не писал, тестировал явно)
сюда же входит создание класса Точки - нам же надо хранить все данные + создание заполнение массива + вызов метода
2) Создаем очередь и оттуда будем вынимать элементы (очередь же) - ЛИФО
В начале добавляется самый первый элемент и он уже "пройден",
вместе с элементами условия в т.ч. посещена точка или нет.
(т.е. к этому элементу вернуться мы обратно не можем, чтобы не было зацикливания!).
Пока очередь не пуста, цикл крутится-пластинки крутятся.
Если пуста - либо мы пришли к намеченной точке, либо туда пройти нельзя.
3) В начале вынимаем из текущего (т.е. на данном этапе первого, а на последующих - по лифо)
элемента очереди все данные. Даже здесь потенциально может выход совпасть с входом, тогда дистанция = 0.
Если мы пришли-таки в конечную точку в течении цикла - нам надо вернуть дистанцию (проверять надо на каждом этапе, да).
4) Самое сложное. У нас есть возможность двигаться по вертикали и по горизонтали (диагональ под запретом).
Верх-низ, право-лево. С массивом этих элементов и будем сравнивать (я разделил на 2 по вертикали и горизонтали).

!Вообще можно вместо 2 массивов создать и 1: {{-1, 0}, {1,0}, {0,-1}, {0,1}}: низ-верх-лево-вправо - это соседние точки
крутиться так или иначе будем по ним, см. LabyrinthAlternativeChecker

Все делаем в цикле из 4 - он же каждый раз может продвигаться на 1 клетку. А как сравнивать и с чем и - почему ?

Ну, у нас есть натуральные преграды - это границы лабирина + поскольку в лабиринте не может быть проходов, искуственные.
Но и то, и то - преграды. Соответственно, перед тем как помечать ноду посещенной
(мы же атм остановились - значит посещена) и добавлять ее в очередь - что есть "центр движухи" в цикле -
(извлечение идет и начала очереди, добавление в конец) - нам надо проверить, а можем ли мы туда идти. Вообще.
Когда не можем ? Когда зона недоступна. А это либо препятствие, либо недоступность, либо уже посещенная нода.

1 и 2 проверка - не вылез ли он за границы. Буквально.
Например 0.0 может как минимум вылезти за границу а) наверх и б) влево (естестенные препятствия).
А чтобы проверить эти 2 варианта, куда мы можем ходить, - сравнение идет с потенциальной точкой:
(или скорее 2*2, т.к. у массива две границы - по-вертикали например это 0 и размер границы самого массива = верх и низ)
может пойти на -1,0 (1 - вертикаль, 2 горизонталь), +1,0 - это по вертикали
или 0,-1 - влево, 0,+1 - вправо. Если иных искуственных препятствий нет - 2 варианта и невалидны сразу.
Какие еще есть варианты, когда не сможем идти ?
Кроме "преград" надо и сравнивть можем ли мы вообще в эту точку попасть - это 0 если можем или 1 - если нет.
(массив клеток заполняется вручную в самом-самом начале).
А также не бывали ли мы в этой точке ранее (если 2 ветки пересекаются, кто 1 там дошел-побывал, ставит тру).

Вот и все, в конце выводим расстояние.
